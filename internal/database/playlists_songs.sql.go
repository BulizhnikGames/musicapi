// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: playlists_songs.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addSongToPlaylist = `-- name: AddSongToPlaylist :one
INSERT INTO playlists_songs (playlist_id, song_id, add_time)
VALUES ($1, $2, $3)
RETURNING playlist_id, song_id, add_time
`

type AddSongToPlaylistParams struct {
	PlaylistID uuid.UUID
	SongID     uuid.UUID
	AddTime    time.Time
}

func (q *Queries) AddSongToPlaylist(ctx context.Context, arg AddSongToPlaylistParams) (PlaylistsSong, error) {
	row := q.db.QueryRowContext(ctx, addSongToPlaylist, arg.PlaylistID, arg.SongID, arg.AddTime)
	var i PlaylistsSong
	err := row.Scan(&i.PlaylistID, &i.SongID, &i.AddTime)
	return i, err
}

const getSongsInPlaylist = `-- name: GetSongsInPlaylist :many
SELECT songs.id, songs.created_at, songs.updated_at, songs.name, songs.album_id FROM songs
JOIN playlists_songs ON playlists_songs.song_id = songs.id
WHERE playlists_songs.playlist_id = $1
ORDER BY add_time ASC
`

func (q *Queries) GetSongsInPlaylist(ctx context.Context, playlistID uuid.UUID) ([]Song, error) {
	rows, err := q.db.QueryContext(ctx, getSongsInPlaylist, playlistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Song
	for rows.Next() {
		var i Song
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.AlbumID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeSongFromPlaylist = `-- name: RemoveSongFromPlaylist :exec
DELETE FROM playlists_songs
WHERE playlist_id = $1 AND song_id = $2
`

type RemoveSongFromPlaylistParams struct {
	PlaylistID uuid.UUID
	SongID     uuid.UUID
}

func (q *Queries) RemoveSongFromPlaylist(ctx context.Context, arg RemoveSongFromPlaylistParams) error {
	_, err := q.db.ExecContext(ctx, removeSongFromPlaylist, arg.PlaylistID, arg.SongID)
	return err
}
